package com.serveme.service.order.api.controller;import com.serveme.service.order.api.dto.input.CreationOrderInputDTO;import com.serveme.service.order.api.dto.input.NewCreationOrderInputDTO;import com.serveme.service.order.api.dto.input.OrderHistoryInputDTO;import com.serveme.service.order.api.dto.input.RatingInputDTO;import com.serveme.service.order.api.dto.output.OrderHistoryOutputDTO;import com.serveme.service.order.api.errors.Errors;import com.serveme.service.order.dao.impl.OrderDao;import com.serveme.service.order.domain.DeviceInformation;import com.serveme.service.order.domain.Order;import com.serveme.service.order.domain.RestaurantDistanceData;import com.serveme.service.order.enums.DeviceType;import com.serveme.service.order.exceptions.InvalidDistanceException;import com.serveme.service.order.external.dto.output.DevicesDTO;import com.serveme.service.order.external.dto.output.UserExDTO;import com.serveme.service.order.external.service.NotificationService;import com.serveme.service.order.external.service.RestaurantService;import com.serveme.service.order.external.service.UserService;import com.serveme.service.order.service.OrderService;import com.serveme.service.order.util.api.httpExceptions.ForbiddenException;import com.serveme.service.order.util.api.httpExceptions.NotFoundException;import org.springframework.beans.factory.annotation.Value;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;import javax.inject.Inject;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.logging.Level;import java.util.logging.Logger;/** * Created by Davids-iMac on 15/11/15. */@Controllerpublic class UserOrderAPI extends OrderAPIBase {    /**     * TODO add secret key input internal services     */    @Value("${order.split.invitations.max}")    protected int orderMaxSplitInvitations;    @Inject    protected OrderDao orderDao;    @Inject    protected RestaurantService restaurantService;    @Inject    protected NotificationService notificationService;    @Inject    protected UserService userService;    @Inject    protected OrderService orderService;    public UserOrderAPI() {        logger = Logger.getLogger(UserOrderAPI.class.getName());    }    @ResponseBody    @RequestMapping(value = "/order/{restaurantId}", method = RequestMethod.POST, produces = "application/json")    public ResponseEntity<Order> makeOrder(            @RequestHeader("access-token") String accessToken,            @PathVariable("restaurantId") long restaurantId,            @RequestBody CreationOrderInputDTO orderInput) {        logger.log(Level.INFO, "POST /order/" + restaurantId);        UserExDTO user = userService.getUser(accessToken);        logger.log(Level.INFO, "By user " + user.toString());        Order currentOrder = orderService.getUserCurrentOrder(user.getId());        if (currentOrder == null) {            if (orderInput.getItems() != null && orderInput.getItems().size() > 0) {                Order order = orderService.createOrder(user, restaurantId, orderInput, accessToken);                DevicesDTO restaurantDevice = restaurantService.getRestaurantDevice(restaurantId);                DevicesDTO adminDevices = restaurantService.getAdminDevices();                notificationService.notificateOrderNew(restaurantDevice, order.getId());                notificationService.notificateOrderNew(adminDevices, order.getId());                DevicesDTO devices = getDevices(order.getId());                orderService.rememberOrder(devices, order, orderInput.getArrivalMinutes());                orderService.autocancelOrderIfNoResponseFromRestaurant(devices, restaurantDevice, adminDevices, order);                return new ResponseEntity(order, HttpStatus.CREATED);            } else {                throw new NotFoundException("Empty item list", Errors.ORDER_WITHOUT_ITEMS.getError());            }        } else {            throw new ForbiddenException("User " + user.getId() + " has already an active orderDao", Errors.ACTIVE_ORDER.getError());        }    }    @ResponseBody    @RequestMapping(value = "/order/v2.0/{restaurantId}", method = RequestMethod.POST, produces = "application/json")    public ResponseEntity<Order> makeOrderVersion2(            @RequestHeader("access-token") String accessToken,            @PathVariable("restaurantId") long restaurantId,            @RequestBody NewCreationOrderInputDTO orderInput) {        //Checking valid distance        RestaurantDistanceData distanceInfo = restaurantService.getValidDistance(restaurantId, orderInput.getLocation());        if (distanceInfo == null || !distanceInfo.isValid()) {            throw new InvalidDistanceException(restaurantId);        }        logger.log(Level.INFO, "POST /order/v2" + restaurantId);        UserExDTO user = userService.getUser(accessToken);        logger.log(Level.INFO, "By user " + user.toString());        Order currentOrder = orderService.getUserCurrentOrder(user.getId());        if (currentOrder == null) {            if (orderInput.getItems() != null && orderInput.getItems().size() > 0) {                Order order = orderService.createOrder(user, restaurantId, orderInput, accessToken);                order.setOriginLocation(orderInput.getLocation());                DevicesDTO restaurantDevice = restaurantService.getRestaurantDevice(restaurantId);                DevicesDTO adminDevices = restaurantService.getAdminDevices();                notificationService.notificateOrderNew(restaurantDevice, order.getId());                notificationService.notificateOrderNew(adminDevices, order.getId());                DevicesDTO devices = getDevices(order.getId());                orderService.rememberOrder(devices, order, orderInput.getArrivalMinutes());                orderService.autocancelOrderIfNoResponseFromRestaurant(devices, restaurantDevice, adminDevices, order);                return new ResponseEntity(order, HttpStatus.CREATED);            } else {                throw new NotFoundException("Empty item list", Errors.ORDER_WITHOUT_ITEMS.getError());            }        } else {            throw new ForbiddenException("User " + user.getId() + " has already an active orderDao", Errors.ACTIVE_ORDER.getError());        }    }    @ResponseBody    @RequestMapping(value = "/order/current", method = RequestMethod.GET, produces = "application/json")    public ResponseEntity<Order> getCurrentOrder(            @RequestHeader("access-token") String accessToken) {        UserExDTO user = userService.getUser(accessToken);        Order order = orderService.getUserCurrentOrder(user.getId());        if (order != null) {            return new ResponseEntity(order, HttpStatus.OK);        } else {            return new ResponseEntity<>(HttpStatus.NOT_FOUND);        }    }    @ResponseBody    @RequestMapping(value = "/order/cancel", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity cancelOrder(            @RequestHeader("access-token") String accessToken, @RequestBody String reason) {        UserExDTO user = userService.getUser(accessToken);        Order order = orderService.getUserCurrentOrder(user.getId());        String orderId = order.getId();        long restaurantId = order.getRestaurant().getId();        if (orderService.cancelOrder(orderId, restaurantId)) {            DevicesDTO devices = getDevices(orderId);            DevicesDTO restaurantDevice = restaurantService.getRestaurantDevice(restaurantId);            DevicesDTO adminDevices = restaurantService.getAdminDevices();            notificationService.notificateOrderCanceled(devices, restaurantDevice, adminDevices, orderId, true);            return new ResponseEntity(HttpStatus.OK);        } else {            return new ResponseEntity<>(HttpStatus.NOT_FOUND);        }    }    @ResponseBody    @RequestMapping(value = "internal/order/countByUser", method = RequestMethod.POST, produces = "application/json")    public List<List<Long>> countOrders(            @RequestHeader("userId") long userId, @RequestBody List<Long> restaurantIds) {        return orderService.getNumberOfOrdersByRestaurant(userId, restaurantIds);    }    @ResponseBody    @RequestMapping(value = "/order/{id}", method = RequestMethod.GET, produces = "application/json")    public ResponseEntity<Order> getOrder(@RequestHeader("access-token") String accessToken, @PathVariable("id") String id) {        UserExDTO user = userService.getUser(accessToken);        Order order = orderService.getById(id, user.getId());        if (order != null) {            return new ResponseEntity<>(order, HttpStatus.OK);        } else {            return new ResponseEntity<>(HttpStatus.NOT_FOUND);        }    }    @ResponseBody    @RequestMapping(value = "/order/history", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity<OrderHistoryOutputDTO> getHistory(@RequestHeader("access-token") String accessToken, @RequestBody OrderHistoryInputDTO orderHistoryInputDTO) {        UserExDTO user = userService.getUser(accessToken);        long count = orderService.countUserHistory(user.getId());        if (count > 0) {            int countInt = getIntOrderCount(count);            int size = orderHistoryInputDTO.getSize() <= 100 ? orderHistoryInputDTO.getSize() : 100;            size = size > countInt ? Math.toIntExact(countInt) : size;            int from = orderHistoryInputDTO.getFrom();            from = orderHistoryInputDTO.getFrom() >= 0 ? from : 0;            List<Order> history = orderService.getUserHistory(user.getId(), from, size);            OrderHistoryOutputDTO output = new OrderHistoryOutputDTO();            output.setOrders(history);            output.setMaxPageSize(size);            output.setTotalCount(countInt);            output.setSize(history != null ? history.size() : 0);            output.setFrom(from);            return new ResponseEntity<>(output, HttpStatus.OK);        } else {            return new ResponseEntity<>(getEmptyOrderHistoryOutput(), HttpStatus.OK);        }    }    @ResponseBody    @RequestMapping(value = "/order/rating", method = RequestMethod.PUT, produces = "application/json")    public void rating(@RequestHeader("access-token") String accessToken, @RequestBody RatingInputDTO rating) {        UserExDTO user = userService.getUser(accessToken);        this.orderService.updateTipAndPayServiceCharge(rating.getOrderId(), rating.getTip(), rating.isPayServiceCharge());        this.orderService.rateOrder(user.getId(), rating.getOrderId(), rating.getRating(), rating.getComments(), rating.getImprovement());    }    /*@ResponseBody    @RequestMapping(value = "/order/split", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity<SplitInvitationOutputDTO> splitBill(@RequestHeader("access-token") String accessToken, @RequestBody List<String> phones) {        UserExDTO user = userService.getUser(accessToken);        Order order = orderService.getUserCurrentOrder(user.getId());        if (order != null) {            if (phones == null) {                throw new BadRequestException("Invitations need at least 1 valid phone", Errors.INVITATIONS_EXCEED.getError());            }            if (phones.size() > orderMaxSplitInvitations                    || (order.getPeople().size() + phones.size() > order.getTableFor())) {                throw new BadRequestException("Invitations exceed for order belonging to " + user.getId(), Errors.INVITATIONS_EXCEED.getError());            }            Map<String, List> result = orderService.splitBill(order, phones);            List<UserExDTO> invited = (List<UserExDTO>) result.get("invited");            notificationService.notificateNewSplitBill(DevicesDTO.parse(invited, order), order.getId());            SplitInvitationOutputDTO invitationOutput = new SplitInvitationOutputDTO();            invitationOutput.setNotFound(result.get("not_found"));            invitationOutput.setWithActiveOrder(withActiveOrderHideFields((List<UserExDTO>) result.get("with_active_order")));            invitationOutput.setInvited(invitedHideFields((List<UserExDTO>) result.get("invited")));            return new ResponseEntity<>(invitationOutput, HttpStatus.OK);        } else {            return new ResponseEntity<>(HttpStatus.NOT_FOUND);        }    }*/    /*******************************************************     * PRIVATE METHODS     *******************************************************/    private OrderHistoryOutputDTO getEmptyOrderHistoryOutput() {        OrderHistoryOutputDTO output = new OrderHistoryOutputDTO();        output.setOrders(new LinkedList<>());        output.setMaxPageSize(0);        output.setTotalCount(0);        output.setSize(0);        output.setFrom(0);        return output;    }    private DevicesDTO getDevices(String orderId) {        Order order = orderService.getById(orderId);        List<Long> IdsOfOwners = new ArrayList<Long>();        IdsOfOwners.add(order.getOwnerId());        List<UserExDTO> objectUserOfOwners = userService.getUserListFromId(IdsOfOwners);        DeviceInformation deviceOfUser = new DeviceInformation();        deviceOfUser.setDeviceId(objectUserOfOwners.get(0).getLastDeviceId());        DeviceType deviceTypeOfUser = stringToDeviceType(objectUserOfOwners.get(0).getLastDeviceType());        deviceOfUser.setDeviceType(deviceTypeOfUser);        List<DeviceInformation> devicesOfOwners = new ArrayList<DeviceInformation>();        devicesOfOwners.add(deviceOfUser);        DevicesDTO devicesOfUser = new DevicesDTO();        devicesOfUser.setDeviceIds(devicesOfOwners);        devicesOfUser.setRestaurantName(order.getRestaurant().getName());        devicesOfUser.setArrivalAt(order.getArrivalAt());        return devicesOfUser;    }    private DeviceType stringToDeviceType(String type) {        if (type.equals("ios")) {            return DeviceType.IOS;        } else {            return DeviceType.ANDROID;        }    }    private int getIntOrderCount(long count) {        try {            return Math.toIntExact(count);        } catch (ArithmeticException ex) {            return Integer.MAX_VALUE;        }    }}