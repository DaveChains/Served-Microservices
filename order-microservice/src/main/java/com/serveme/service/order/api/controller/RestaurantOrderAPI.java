package com.serveme.service.order.api.controller;import com.serveme.service.order.api.dto.input.ChargeInputDTO;import com.serveme.service.order.api.dto.input.DatesInputDTO;import com.serveme.service.order.api.dto.input.InvoiceHistoryInputDTO;import com.serveme.service.order.api.dto.input.OrderHistoryInputDTO;import com.serveme.service.order.api.dto.output.OrderHistoryOutputDTO;import com.serveme.service.order.dao.impl.OrderDao;import com.serveme.service.order.dao.impl.TestDao;import com.serveme.service.order.domain.*;import com.serveme.service.order.enums.DeviceType;import com.serveme.service.order.external.dto.output.DevicesDTO;import com.serveme.service.order.external.dto.output.UserExDTO;import com.serveme.service.order.external.dto.output.UserRestaurantExDTO;import com.serveme.service.order.external.service.NotificationService;import com.serveme.service.order.external.service.RestaurantService;import com.serveme.service.order.external.service.UserService;import com.serveme.service.order.service.OrderService;import org.springframework.beans.factory.annotation.Value;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;import javax.inject.Inject;import javax.ws.rs.QueryParam;import java.math.BigDecimal;import java.util.ArrayList;import java.util.Date;import java.util.LinkedList;import java.util.List;import java.util.logging.Level;import java.util.logging.Logger;/** * Created by Davids-iMac on 15/11/15. */@Controllerpublic class RestaurantOrderAPI extends OrderAPIBase {    /**     * TODO add secret key input internal services     */    @Inject    protected OrderDao orderDao;    @Inject    protected RestaurantService restaurantService;    @Inject    protected UserService userService;    @Inject    protected OrderService orderService;    @Inject    protected NotificationService notificationService;    @Value("${admin.token}")    private String adminToken;    @Inject    private TestDao testDao;    public RestaurantOrderAPI() {        logger = Logger.getLogger(UserOrderAPI.class.getName());    }    @ResponseBody    @RequestMapping(value = "/order/test", method = RequestMethod.POST, produces = "application/json")    public ResponseEntity test1(@QueryParam("key") String key, @QueryParam("value") String value) {        try {            return ResponseEntity.ok(testDao.create(new TestDomain(key, value)));        } catch (Exception ex) {            return ResponseEntity.status(500).body(ex);        }    }    @ResponseBody    @RequestMapping(value = "/order/test/{key}", method = RequestMethod.GET, produces = "application/json")    public ResponseEntity test2(@PathVariable("key") String key) {        try {            TestDomain t = testDao.findByKey(key);            return ResponseEntity.ok(t);        } catch (Exception ex) {            return ResponseEntity.status(500).body(ex);        }    }    @ResponseBody    @RequestMapping(value = "/restaurant/order/test", method = RequestMethod.POST, produces = "application/json")    public ResponseEntity test3(@QueryParam("key") String key, @QueryParam("value") String value) {        try {            return ResponseEntity.ok(testDao.create(new TestDomain(key, value)));        } catch (Exception ex) {            return ResponseEntity.status(500).body(ex);        }    }    @ResponseBody    @RequestMapping(value = "/restaurant/order/test/{key}", method = RequestMethod.GET, produces = "application/json")    public ResponseEntity test4(@PathVariable("key") String key) {        try {            TestDomain t = testDao.findByKey(key);            return ResponseEntity.ok(t);        } catch (Exception ex) {            return ResponseEntity.status(500).body(ex);        }    }    @ResponseBody    @RequestMapping(value = "/order/restaurant/{id}", method = RequestMethod.GET, produces = "application/json")    public ResponseEntity<Order> getOrder(@PathVariable("id") String id,                                          @RequestHeader("access-token") String restaurantAccessToken) {        Order order = orderService.getById(id);        if (order != null) {            if (restaurantAccessToken.equals(adminToken)) {                return new ResponseEntity<Order>(order, HttpStatus.OK);            }            UserRestaurantExDTO restaurantUser = restaurantService.authRestaurant(restaurantAccessToken);            if (order.getRestaurant().getId() == restaurantUser.getRestaurantId()) {                return new ResponseEntity<Order>(order, HttpStatus.OK);            } else {                return new ResponseEntity<>(HttpStatus.FORBIDDEN);            }        } else {            return new ResponseEntity<>(HttpStatus.NOT_FOUND);        }    }    //method for mobile restaurant    @ResponseBody    @RequestMapping(value = "/restaurant/order/summary", method = RequestMethod.POST, produces = "application/json")    public ResponseEntity<SummaryDomain> getSummary(            @RequestHeader("access-token") String restaurantAccessToken,            @RequestBody DatesInputDTO datesInputDTO) {        logger.log(Level.INFO, restaurantAccessToken);        UserRestaurantExDTO restaurantUser = restaurantService.authRestaurant(restaurantAccessToken);        List<Order> orders = orderService.getRestaurantFinishedOrders(restaurantUser.getRestaurantId(),                datesInputDTO.getInitDate().getTime(), datesInputDTO.getEndDate().getTime());        orders = Order.removeTestOrders(orders);        SummaryDomain summary = new SummaryDomain(orders, datesInputDTO.getInitDate(), datesInputDTO.getEndDate());        return new ResponseEntity<>(summary, HttpStatus.OK);    }    //method for superadmin    @ResponseBody    @RequestMapping(value = "/order/restaurant/{restaurantId}/summary", method = RequestMethod.POST, produces = "application/json")    public ResponseEntity<SummaryDomain> getSummary(            @RequestHeader("access-token") String restaurantAccessToken,            @PathVariable("restaurantId") long restaurantId,            @RequestBody DatesInputDTO datesInputDTO) {        logger.log(Level.INFO, restaurantAccessToken);        boolean isAdmin = true;        if (!restaurantAccessToken.equals(adminToken)) {            UserRestaurantExDTO restaurantUser = restaurantService.authRestaurant(restaurantAccessToken);            restaurantId = restaurantUser.getRestaurantId();            isAdmin = false;        }        List<Order> orders = orderService.getRestaurantFinishedOrders(restaurantId,                datesInputDTO.getInitDate().getTime(), datesInputDTO.getEndDate().getTime());        if (!isAdmin) {            orders = Order.removeTestOrders(orders);        }        SummaryDomain summary = new SummaryDomain(orders, datesInputDTO.getInitDate(), datesInputDTO.getEndDate());        return new ResponseEntity<>(summary, HttpStatus.OK);    }    @ResponseBody    @RequestMapping(value = "/restaurant/order/history", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity<OrderHistoryOutputDTO> getHistory(            @RequestHeader("access-token") String restaurantAccessToken,            @RequestBody OrderHistoryInputDTO orderHistoryInputDTO) {        logger.log(Level.INFO, restaurantAccessToken);        if (restaurantAccessToken.equals(adminToken)) {            return adminGetHistory(orderHistoryInputDTO.getFrom(), orderHistoryInputDTO.getSize());        }        UserRestaurantExDTO restaurantUser = restaurantService.authRestaurant(restaurantAccessToken);        long count = orderService.countRestaurantHistory(restaurantUser.getRestaurantId());        if (count > 0) {            int countInt = getIntOrderCount(count);            int size = orderHistoryInputDTO.getSize() <= 100 ? orderHistoryInputDTO.getSize() : 100;            size = size > countInt ? Math.toIntExact(countInt) : size;            int from = orderHistoryInputDTO.getFrom();            from = orderHistoryInputDTO.getFrom() >= 0 ? from : 0;            List<Order> history = orderService.getRestaurantHistory(restaurantUser.getRestaurantId(), from, size);            history = Order.removeTestOrders(history);            OrderHistoryOutputDTO output = new OrderHistoryOutputDTO();            output.setOrders(history);            output.setMaxPageSize(size);            output.setTotalCount(countInt);            output.setSize(history != null ? history.size() : 0);            output.setFrom(from);            return new ResponseEntity<>(output, HttpStatus.OK);        } else {            return new ResponseEntity<>(getEmptyOrderHistoryOutput(), HttpStatus.OK);        }    }    //method for superadmin    @ResponseBody    @RequestMapping(value = "/order/restaurant/{restaurantId}/history", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity<OrderHistoryOutputDTO> getHistory(            @RequestHeader("access-token") String restaurantAccessToken,            @PathVariable("restaurantId") long restaurantId,            @RequestBody OrderHistoryInputDTO orderHistoryInputDTO) {        logger.log(Level.INFO, restaurantAccessToken);        boolean isAdmin = true;        if (!restaurantAccessToken.equals(adminToken)) {            UserRestaurantExDTO restaurantUser = restaurantService.authRestaurant(restaurantAccessToken);            restaurantId = restaurantUser.getRestaurantId();            isAdmin = false;        }        long count = orderService.countRestaurantHistory(restaurantId);        if (count > 0) {            int countInt = getIntOrderCount(count);            int size = orderHistoryInputDTO.getSize() <= 100 ? orderHistoryInputDTO.getSize() : 100;            size = size > countInt ? Math.toIntExact(countInt) : size;            int from = orderHistoryInputDTO.getFrom();            from = orderHistoryInputDTO.getFrom() >= 0 ? from : 0;            List<Order> history = orderService.getRestaurantHistory(restaurantId, from, size);            if (!isAdmin) {                history = Order.removeTestOrders(history);            }            OrderHistoryOutputDTO output = new OrderHistoryOutputDTO();            output.setOrders(history);            output.setMaxPageSize(size);            output.setTotalCount(countInt);            output.setSize(history != null ? history.size() : 0);            output.setFrom(from);            return new ResponseEntity<>(output, HttpStatus.OK);        } else {            return new ResponseEntity<>(getEmptyOrderHistoryOutput(), HttpStatus.OK);        }    }    @ResponseBody    @RequestMapping(value = "/order/restaurant/{restaurantId}/invoices", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity<List<Invoice>> getInvoices(            @RequestHeader("access-token") String restaurantAccessToken,            @PathVariable("restaurantId") long restaurantId,            @RequestBody InvoiceHistoryInputDTO orderHistoryInputDTO) {        if (!restaurantAccessToken.equals(adminToken)) {            UserRestaurantExDTO restaurantUser = restaurantService.authRestaurant(restaurantAccessToken);            restaurantId = restaurantUser.getRestaurantId();        }        List<Invoice> invoices = orderService.getInvoices(restaurantId,                orderHistoryInputDTO.getFrom(), orderHistoryInputDTO.getSize());        return new ResponseEntity<>(invoices, HttpStatus.OK);    }    @ResponseBody    @RequestMapping(value = "/restaurant/order/pending", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity<OrderHistoryOutputDTO> getPendingOrders(            @RequestHeader("access-token") String restaurantAccessToken,            @RequestBody OrderHistoryInputDTO orderHistoryInputDTO) {        logger.log(Level.INFO, restaurantAccessToken);        if (restaurantAccessToken.equals(adminToken)) {            return adminGetPending(orderHistoryInputDTO.getFrom(), orderHistoryInputDTO.getSize());        }        UserRestaurantExDTO restaurantUser = restaurantService.authRestaurant(restaurantAccessToken);        long count = orderService.countRestaurantPending(restaurantUser.getRestaurantId());        if (count > 0) {            int countInt = getIntOrderCount(count);            int size = orderHistoryInputDTO.getSize() <= 100 ? orderHistoryInputDTO.getSize() : 100;            size = size > countInt ? Math.toIntExact(countInt) : size;            int from = orderHistoryInputDTO.getFrom();            from = orderHistoryInputDTO.getFrom() >= 0 ? from : 0;            List<Order> history = orderService.getRestaurantPendingOrders(restaurantUser.getRestaurantId(), from, size);            OrderHistoryOutputDTO output = new OrderHistoryOutputDTO();            output.setOrders(history);            output.setMaxPageSize(size);            output.setTotalCount(countInt);            output.setSize(history != null ? history.size() : 0);            output.setFrom(from);            return new ResponseEntity<>(output, HttpStatus.OK);        } else {            return new ResponseEntity<>(getEmptyOrderHistoryOutput(), HttpStatus.OK);        }    }    @ResponseBody    @RequestMapping(value = "internal/order/{id}/registerCharge", method = RequestMethod.POST, produces = "application/json")    public ResponseEntity<Order> RegisterCharge(@PathVariable("id") String id,                                                @RequestBody ChargeInputDTO chargeInput) {        Order order = orderService.getById(id);        if (order != null) {            orderService.saveCharge(order, chargeInput.getAmountCharged(), chargeInput.getChargeId());            return new ResponseEntity<>(order, HttpStatus.OK);        } else {            return new ResponseEntity<>(HttpStatus.NOT_FOUND);        }    }    @ResponseBody    @RequestMapping(value = "internal/order/notCharged", method = RequestMethod.GET, produces = "application/json")    public ResponseEntity<List<Order>> getNotChargedOrders(@RequestParam int max) {        List<Order> output = orderService.getNotCharged(max);        return new ResponseEntity<>(output, HttpStatus.OK);    }    @ResponseBody    @RequestMapping(value = "/restaurant/order/finished", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity<OrderHistoryOutputDTO> getFinishedOrders(            @RequestHeader("access-token") String restaurantAccessToken,            @RequestBody OrderHistoryInputDTO orderHistoryInputDTO) {        logger.log(Level.INFO, restaurantAccessToken);        if (restaurantAccessToken.equals(adminToken)) {            //not used in admin            return adminGetHistory(orderHistoryInputDTO.getFrom(), orderHistoryInputDTO.getSize());        }        Date now = new Date();        long startOfDay = new Date(now.getYear(), now.getMonth(), now.getDate()).getTime();        UserRestaurantExDTO restaurantUser = restaurantService.authRestaurant(restaurantAccessToken);        long count = orderService.countRestaurantFinished(restaurantUser.getRestaurantId(), startOfDay);        if (count > 0) {            int countInt = getIntOrderCount(count);            int size = orderHistoryInputDTO.getSize() <= 100 ? orderHistoryInputDTO.getSize() : 100;            size = size > countInt ? Math.toIntExact(countInt) : size;            int from = orderHistoryInputDTO.getFrom();            from = orderHistoryInputDTO.getFrom() >= 0 ? from : 0;            List<Order> history = orderService.getRestaurantFinishedOrders(restaurantUser.getRestaurantId(), from, size, startOfDay);            OrderHistoryOutputDTO output = new OrderHistoryOutputDTO();            output.setOrders(history);            output.setMaxPageSize(size);            output.setTotalCount(countInt);            output.setSize(history != null ? history.size() : 0);            output.setFrom(from);            return new ResponseEntity<>(output, HttpStatus.OK);        } else {            return new ResponseEntity<>(getEmptyOrderHistoryOutput(), HttpStatus.OK);        }    }    @ResponseBody    @RequestMapping(value = "/restaurant/order/accepted", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity<OrderHistoryOutputDTO> getAcceptedOrders(            @RequestHeader("access-token") String restaurantAccessToken,            @RequestBody OrderHistoryInputDTO orderHistoryInputDTO) {        logger.log(Level.INFO, restaurantAccessToken);        if (restaurantAccessToken.equals(adminToken)) {            return adminGetAccepted(orderHistoryInputDTO.getFrom(), orderHistoryInputDTO.getSize());        }        UserRestaurantExDTO restaurantUser = restaurantService.authRestaurant(restaurantAccessToken);        long count = orderService.countRestaurantAccepted(restaurantUser.getRestaurantId());        if (count > 0) {            int countInt = getIntOrderCount(count);            int size = orderHistoryInputDTO.getSize() <= 100 ? orderHistoryInputDTO.getSize() : 100;            size = size > countInt ? Math.toIntExact(countInt) : size;            int from = orderHistoryInputDTO.getFrom();            from = orderHistoryInputDTO.getFrom() >= 0 ? from : 0;            List<Order> history = orderService.getRestaurantAcceptedOrders(restaurantUser.getRestaurantId(), from, size);            OrderHistoryOutputDTO output = new OrderHistoryOutputDTO();            output.setOrders(history);            output.setMaxPageSize(size);            output.setTotalCount(countInt);            output.setSize(history != null ? history.size() : 0);            output.setFrom(from);            return new ResponseEntity<>(output, HttpStatus.OK);        } else {            return new ResponseEntity<>(getEmptyOrderHistoryOutput(), HttpStatus.OK);        }    }    @ResponseBody    @RequestMapping(value = "/restaurant/order/active", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity<OrderHistoryOutputDTO> getActiveOrders(            @RequestHeader("access-token") String restaurantAccessToken,            @RequestBody OrderHistoryInputDTO orderHistoryInputDTO) {        if (restaurantAccessToken.equals(adminToken)) {            return adminGetActive(orderHistoryInputDTO.getFrom(), orderHistoryInputDTO.getSize());        }        UserRestaurantExDTO restaurantUser = restaurantService.authRestaurant(restaurantAccessToken);        long count = orderService.countRestaurantActive(restaurantUser.getRestaurantId());        if (count > 0) {            int countInt = getIntOrderCount(count);            int size = orderHistoryInputDTO.getSize() <= 100 ? orderHistoryInputDTO.getSize() : 100;            size = size > countInt ? Math.toIntExact(countInt) : size;            int from = orderHistoryInputDTO.getFrom();            from = orderHistoryInputDTO.getFrom() >= 0 ? from : 0;            List<Order> history = orderService.getRestaurantActiveOrders(restaurantUser.getRestaurantId(), from, size);            OrderHistoryOutputDTO output = new OrderHistoryOutputDTO();            output.setOrders(history);            output.setMaxPageSize(size);            output.setTotalCount(countInt);            output.setSize(history != null ? history.size() : 0);            output.setFrom(from);            return new ResponseEntity<>(output, HttpStatus.OK);        } else {            return new ResponseEntity<>(getEmptyOrderHistoryOutput(), HttpStatus.OK);        }    }    @ResponseBody    @RequestMapping(value = "/order/{orderId}/accept", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity acceptOder(            @RequestHeader("access-token") String restaurantAccessToken,            @PathVariable("orderId") String orderId    ) {        logger.log(Level.INFO, "PUT /order/" + orderId + "/accept");        if (restaurantAccessToken.equals(adminToken)) {            return adminAcceptOrder(orderId);        }        UserRestaurantExDTO restaurantUser = restaurantService.authRestaurant(restaurantAccessToken);        logger.log(Level.INFO, "UserRestaurantId : " + restaurantUser.getId());        if (orderService.acceptOrder(orderId, restaurantUser.getRestaurantId())) {            logger.log(Level.INFO, orderId + " ACCEPTED");            DevicesDTO devices = getDevices(orderId);            logger.log(Level.INFO, "devices to be accepted:\n" + (devices != null ? devices.toString() : "NONE"));            notificationService.notificateOrderAccepted(devices, orderId);            return new ResponseEntity(HttpStatus.OK);        } else {            return new ResponseEntity(HttpStatus.BAD_REQUEST);        }    }    @ResponseBody    @RequestMapping(value = "/order/{orderId}/finish", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity finishOrder(            @RequestHeader("access-token") String restaurantAccessToken,            @PathVariable("orderId") String orderId) {        return finishOrder(restaurantAccessToken, orderId, null);    }    @ResponseBody    @RequestMapping(value = "/order/{orderId}/finish", method = RequestMethod.POST, produces = "application/json")    public ResponseEntity finishOrder(            @RequestHeader("access-token") String restaurantAccessToken,            @PathVariable("orderId") String orderId,            @RequestBody BigDecimal orderedAtRestaurant    ) {        logger.log(Level.INFO, "PUT /order/" + orderId + "/finish");        if (restaurantAccessToken.equals(adminToken)) {            return adminFinishOrder(orderId, orderedAtRestaurant);        }        UserRestaurantExDTO restaurantUser = restaurantService.authRestaurant(restaurantAccessToken);        if (orderService.finishOrder(orderId, restaurantUser.getRestaurantId(), orderedAtRestaurant)) {            DevicesDTO devices = getDevices(orderId);            notificationService.notificateOrderFinished(devices, orderId);            return new ResponseEntity(HttpStatus.OK);        } else {            return new ResponseEntity(HttpStatus.BAD_REQUEST);        }    }    @ResponseBody    @RequestMapping(value = "/order/{orderId}/decline", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity declineOrder(            @RequestHeader("access-token") String restaurantAccessToken,            @PathVariable("orderId") String orderId    ) {        logger.log(Level.INFO, "PUT /order/" + orderId + "/decline");        if (restaurantAccessToken.equals(adminToken)) {            return adminDeclineOrder(orderId);        }        UserRestaurantExDTO restaurantUser = restaurantService.authRestaurant(restaurantAccessToken);        if (orderService.declineOrder(orderId, restaurantUser.getRestaurantId())) {            DevicesDTO devices = getDevices(orderId);            notificationService.notificateOrderDeclined(devices, orderId);            return new ResponseEntity(HttpStatus.OK);        } else {            return new ResponseEntity(HttpStatus.BAD_REQUEST);        }    }    /**     * Method for restaurant application     */    @ResponseBody    @RequestMapping(value = "/order/{orderId}/cancel", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity cancelOrder(            @RequestHeader("access-token") String restaurantAccessToken,            @PathVariable("orderId") String orderId    ) {        logger.log(Level.INFO, "PUT /order/" + orderId + "/cancel");        if (restaurantAccessToken.equals(adminToken)) {            return adminCancelOrder(orderId);        }        UserRestaurantExDTO restaurantUser = restaurantService.authRestaurant(restaurantAccessToken);        if (orderService.cancelOrder(orderId, restaurantUser.getRestaurantId())) {            DevicesDTO devices = getDevices(orderId);            DevicesDTO restaurantDevice = restaurantService.getRestaurantDevice(restaurantUser.getRestaurantId());            DevicesDTO adminDevices = restaurantService.getAdminDevices();            notificationService.notificateOrderCanceled(devices, restaurantDevice, adminDevices, orderId, false);            return new ResponseEntity(HttpStatus.OK);        } else {            return new ResponseEntity(HttpStatus.BAD_REQUEST);        }    }    @ResponseBody    @RequestMapping(value = "/order/invoice/{invoiceId}/invoiceWasTransferred", method = RequestMethod.GET, produces = "application/json")    public ResponseEntity setOrderToTransferred(            @PathVariable("invoiceId") String invoiceId    ) {        orderService.setInvoiceToTransferred(invoiceId);        return new ResponseEntity(HttpStatus.OK);    }    /*******************************************************     * ADMIN METHODS     *******************************************************/    //@ResponseBody    //@RequestMapping(value = "/test_order/{orderId}/accept", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity adminAcceptOrder(            @PathVariable("orderId") String orderId) {        logger.log(Level.INFO, "PUT /test_order/" + orderId + "/accept");        if (orderService.acceptOrder(orderId)) {            DevicesDTO devices = getDevices(orderId);            notificationService.notificateOrderAccepted(devices, orderId);            return new ResponseEntity(HttpStatus.OK);        } else {            logger.log(Level.INFO, orderId + " couldn't be accepted");            return new ResponseEntity(HttpStatus.BAD_REQUEST);        }    }    //@ResponseBody    //@RequestMapping(value = "/test_order/{orderId}/decline", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity adminDeclineOrder(            @PathVariable("orderId") String orderId) {        if (orderService.declineOrder(orderId)) {            DevicesDTO devices = getDevices(orderId);            notificationService.notificateOrderDeclined(devices, orderId);            return new ResponseEntity(HttpStatus.OK);        } else {            return new ResponseEntity(HttpStatus.BAD_REQUEST);        }    }    //@ResponseBody    //@RequestMapping(value = "/test_order/{orderId}/cancel", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity adminCancelOrder(            @PathVariable("orderId") String orderId) {        long restaurantId = orderDao.getById(orderId).getRestaurant().getId();        if (orderService.cancelOrder(orderId)) {            DevicesDTO devices = getDevices(orderId);            DevicesDTO restaurantDevice = restaurantService.getRestaurantDevice(restaurantId);            DevicesDTO adminDevices = restaurantService.getAdminDevices();            notificationService.notificateOrderCanceled(devices, restaurantDevice, adminDevices, orderId, false);            return new ResponseEntity(HttpStatus.OK);        } else {            return new ResponseEntity(HttpStatus.BAD_REQUEST);        }    }    //@ResponseBody    //@RequestMapping(value = "/test_order/{orderId}/finish", method = RequestMethod.PUT, produces = "application/json")    public ResponseEntity adminFinishOrder(            @PathVariable("orderId") String orderId,            @RequestBody BigDecimal orderedAtRestaurant) {        if (orderService.finishOrder(orderId, orderedAtRestaurant)) {            DevicesDTO devices = getDevices(orderId);            notificationService.notificateOrderFinished(devices, orderId);            return new ResponseEntity(HttpStatus.OK);        } else {            return new ResponseEntity(HttpStatus.BAD_REQUEST);        }    }    public ResponseEntity<OrderHistoryOutputDTO> adminGetHistory(int fromRequest, int sizeRequest) {        List<Order> history = orderService.getAllHistory(fromRequest, sizeRequest);        long count = history.size();        if (count > 0) {            int countInt = getIntOrderCount(count);            int size = sizeRequest <= 100 ? sizeRequest : 100;            size = size > countInt ? Math.toIntExact(countInt) : size;            int from = fromRequest;            from = fromRequest >= 0 ? from : 0;            OrderHistoryOutputDTO output = new OrderHistoryOutputDTO();            output.setOrders(history);            output.setMaxPageSize(size);            output.setTotalCount(countInt);            output.setSize(history.size());            output.setFrom(from);            return new ResponseEntity<>(output, HttpStatus.OK);        }        return new ResponseEntity<>(getEmptyOrderHistoryOutput(), HttpStatus.OK);    }    public ResponseEntity<OrderHistoryOutputDTO> adminGetPending(int fromRequest, int sizeRequest) {        List<Order> history = orderService.getAllPendingOrders(fromRequest, sizeRequest);        long count = history.size();        if (count > 0) {            int countInt = getIntOrderCount(count);            int size = sizeRequest <= 100 ? sizeRequest : 100;            size = size > countInt ? Math.toIntExact(countInt) : size;            int from = fromRequest;            from = fromRequest >= 0 ? from : 0;            OrderHistoryOutputDTO output = new OrderHistoryOutputDTO();            output.setOrders(history);            output.setMaxPageSize(size);            output.setTotalCount(countInt);            output.setSize(history != null ? history.size() : 0);            output.setFrom(from);            return new ResponseEntity<>(output, HttpStatus.OK);        }        return new ResponseEntity<>(getEmptyOrderHistoryOutput(), HttpStatus.OK);    }    public ResponseEntity<OrderHistoryOutputDTO> adminGetAccepted(int fromRequest, int sizeRequest) {        List<Order> history = orderService.getAllAcceptedOrders(fromRequest, sizeRequest);        long count = history.size();        if (count > 0) {            int countInt = getIntOrderCount(count);            int size = sizeRequest <= 100 ? sizeRequest : 100;            size = size > countInt ? Math.toIntExact(countInt) : size;            int from = fromRequest;            from = fromRequest >= 0 ? from : 0;            OrderHistoryOutputDTO output = new OrderHistoryOutputDTO();            output.setOrders(history);            output.setMaxPageSize(size);            output.setTotalCount(countInt);            output.setSize(history != null ? history.size() : 0);            output.setFrom(from);            return new ResponseEntity<>(output, HttpStatus.OK);        }        return new ResponseEntity<>(getEmptyOrderHistoryOutput(), HttpStatus.OK);    }    public ResponseEntity<OrderHistoryOutputDTO> adminGetActive(int fromRequest, int sizeRequest) {        List<Order> history = orderService.getAllActiveOrders(fromRequest, sizeRequest);        long count = history.size();        if (count > 0) {            int countInt = getIntOrderCount(count);            int size = sizeRequest <= 100 ? sizeRequest : 100;            size = size > countInt ? Math.toIntExact(countInt) : size;            int from = fromRequest;            from = fromRequest >= 0 ? from : 0;            OrderHistoryOutputDTO output = new OrderHistoryOutputDTO();            output.setOrders(history);            output.setMaxPageSize(size);            output.setTotalCount(countInt);            output.setSize(history != null ? history.size() : 0);            output.setFrom(from);            return new ResponseEntity<>(output, HttpStatus.OK);        }        return new ResponseEntity<>(getEmptyOrderHistoryOutput(), HttpStatus.OK);    }    /*******************************************************     * PRIVATE METHODS     *******************************************************/    private OrderHistoryOutputDTO getEmptyOrderHistoryOutput() {        OrderHistoryOutputDTO output = new OrderHistoryOutputDTO();        output.setOrders(new LinkedList<>());        output.setMaxPageSize(0);        output.setTotalCount(0);        output.setSize(0);        output.setFrom(0);        return output;    }    private DevicesDTO getDevices(String orderId) {        Order order = orderService.getById(orderId);        List<Long> userIds = new ArrayList<Long>();        for (OrderPeople user : order.getPeople()) {            userIds.add(user.getUserId());        }        List<UserExDTO> users = userService.getUserListFromId(userIds);        List<DeviceInformation> deviceInformations = new ArrayList<DeviceInformation>();        for (UserExDTO user : users) {            DeviceInformation userDevice = new DeviceInformation();            userDevice.setDeviceId(user.getLastDeviceId());            userDevice.setDeviceType(stringToDeviceType(user.getLastDeviceType()));            deviceInformations.add(userDevice);        }        DevicesDTO usersDevices = new DevicesDTO();        usersDevices.setDeviceIds(deviceInformations);        usersDevices.setRestaurantName(order.getRestaurant().getName());        usersDevices.setArrivalAt(order.getArrivalAt());        return usersDevices;    }    private DeviceType stringToDeviceType(String type) {        if (type.equals("ios")) {            return DeviceType.IOS;        } else {            return DeviceType.ANDROID;        }    }    private int getIntOrderCount(long count) {        try {            return Math.toIntExact(count);        } catch (ArithmeticException ex) {            return Integer.MAX_VALUE;        }    }}